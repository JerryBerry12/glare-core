//
// Generated by makeclass.rb on Sat Feb 13 21:34:45 +1300 2010.
// Copyright Nicholas Chapman.
//
#pragma once


#include "MyThread.h"
#include "platformutils.h"
#include "../maths/mathstypes.h"


template <class T>
class ParallelForThread : public MyThread
{
public:
	ParallelForThread(T& t_, int begin_, int end_, int step_) : t(t_), begin(begin_), end(end_), step(step_) {}
	T& t;
	int begin, end, step;
	virtual void run()
	{
		for(int i=begin; i<end; i+=step)
			t(i);
	}
};


class ParallelFor
{
public:
	ParallelFor();
	~ParallelFor();
	
	template <class T>
	static void exec(T& t, int begin, int end)
	{
		if(begin >= end)
			return;

		const int total = end - begin;
		const int max_num_threads = myMax(1u, PlatformUtils::getNumLogicalProcessors());
		int num_indices_per_thread = 0;
		int num_threads = 0;
		if(total <= max_num_threads)
		{
			num_threads = total;
			num_indices_per_thread = 1;
		}
		else if(total % max_num_threads == 0)
		{
			// If max_num_threads divides total perfectly
			num_threads = max_num_threads;
			num_indices_per_thread = total / num_threads;
		}
		else
		{
			num_threads = max_num_threads;
			num_indices_per_thread = (total / num_threads) + 1;
		}


		ParallelForThread<T>** threads = new ParallelForThread<T>*[end - begin];
		//int i=begin;
		for(int thread_i=0; thread_i<num_threads; ++thread_i)
		{
			//const int thread_begin = i;
			//const int thread_end = myMin(i + num_indices_per_thread, end);
			const int thread_begin = begin + thread_i;
			const int thread_end = end;//myMin(i + num_indices_per_thread, end);
			const int step = num_threads;

			assert(thread_begin >= begin);
			assert(thread_end >= thread_begin);
			assert(thread_end <= end);

			threads[thread_i] = new ParallelForThread<T>(
				t, 
				thread_begin, // begin
				thread_end, // end
				step
				);
			threads[thread_i]->launch(
				false // autodelete
			);

			//i += num_indices_per_thread;
		}
		assert(i >= end);

		//for(int thread_i=0; thread_i<num_threads; ++thread_i)
		//	threads[thread_i]->launch(false);



		// Wait for threads to terminate
		for(int thread_i=0; thread_i<num_threads; ++thread_i)
		{
			threads[thread_i]->join();
			delete threads[thread_i];
		}

		// Delete threads
		//for(int i=begin; i!=end; ++i)
		//	delete threads[i - begin];
	}
};
